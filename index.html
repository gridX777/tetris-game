<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Tetris Stage 3 â€“ Rewarded Ads</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
html,body{
  margin:0;height:100%;
  background:#0f172a;color:#e5e7eb;
  font-family:system-ui;
  overflow:hidden;
}
.wrap{
  display:flex;gap:12px;
  justify-content:center;
  align-items:flex-start;
  padding:10px;
}
canvas{
  background:#020617;
  border:3px solid #38bdf8;
}
.panel{
  display:flex;
  flex-direction:column;
  gap:6px;
}
h3{margin:0;font-size:14px;text-align:center}
#info{font-size:12px;text-align:center}

/* GAME OVER OVERLAY */
#gameOver{
  position:fixed;inset:0;
  background:rgba(2,6,23,.95);
  display:none;
  align-items:center;
  justify-content:center;
  z-index:999;
}
#gameOver .box{
  background:#020617;
  border:3px solid #38bdf8;
  padding:20px;
  width:280px;
  text-align:center;
}
#gameOver button{
  width:100%;
  padding:10px;
  margin-top:10px;
  background:#38bdf8;
  border:none;
  font-weight:bold;
  cursor:pointer;
}
</style>
</head>
<body>

<div class="wrap">
  <canvas id="game" width="120" height="240"></canvas>
  <div class="panel">
    <h3>Next</h3>
    <canvas id="next" width="120" height="300"></canvas>
    <h3>Hold</h3>
    <canvas id="hold" width="120" height="120"></canvas>
    <div id="info"></div>
  </div>
</div>

<div id="gameOver">
  <div class="box">
    <h2>Game Over</h2>
    <button id="watchAd">Watch Ad & Continue</button>
    <button id="restart">Restart</button>
  </div>
</div>

<script>
// ================= ADS =================
const ADS=[
  "https://otieu.com/4/10341163",
  "https://otieu.com/4/10341164",
  "https://otieu.com/4/10341165",
  "https://otieu.com/4/10341171"
];
function openAd(){
  const url = ADS[Math.floor(Math.random()*ADS.length)];
  window.open(url, "_blank", "noopener");
}

// ================= CONFIG =================
const COLS=10, ROWS=20, SIZE=12;
const canvas=document.getElementById('game');
const ctx=canvas.getContext('2d');
ctx.scale(SIZE,SIZE);

const nextC=document.getElementById('next');
const nctx=nextC.getContext('2d');
nctx.scale(15,15);

const holdC=document.getElementById('hold');
const hctx=holdC.getContext('2d');
hctx.scale(15,15);

const info=document.getElementById('info');

// ================= PIECES =================
const PIECES={
 I:[[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
 J:[[1,0,0],[1,1,1],[0,0,0]],
 L:[[0,0,1],[1,1,1],[0,0,0]],
 O:[[1,1],[1,1]],
 S:[[0,1,1],[1,1,0],[0,0,0]],
 T:[[0,1,0],[1,1,1],[0,0,0]],
 Z:[[1,1,0],[0,1,1],[0,0,0]]
};
const COLORS={
 I:'#22d3ee',J:'#3b82f6',L:'#f97316',
 O:'#fde047',S:'#22c55e',T:'#a855f7',Z:'#ef4444'
};

// ================= BAG =================
class Bag{
  constructor(){this.refill()}
  refill(){
    this.b=['I','J','L','O','S','T','Z'];
    for(let i=this.b.length-1;i>0;i--){
      const j=Math.floor(Math.random()*(i+1));
      [this.b[i],this.b[j]]=[this.b[j],this.b[i]];
    }
  }
  next(){
    if(!this.b.length) this.refill();
    return this.b.pop();
  }
}
const bag=new Bag();

// ================= STATE =================
const arena=Array.from({length:ROWS},()=>Array(COLS).fill(0));
let queue=[bag.next(),bag.next(),bag.next()];
let player=null, hold=null, canHold=true;

let score=0, lines=0, level=1;
let dropInt=1000, dropCnt=0;
let lastTime=0;
let isGameOver=false;
let animationId=null;

// ================= HELPERS =================
const collide=p=>p.m.some((r,y)=>
  r.some((v,x)=>v && (arena[y+p.y]?.[x+p.x]!==0))
);
const rotate=m=>m[0].map((_,i)=>m.map(r=>r[i]).reverse());

function drawM(m,o,c,t,a=1){
  c.globalAlpha=a;
  c.fillStyle=COLORS[t];
  m.forEach((r,y)=>r.forEach((v,x)=>{
    if(v) c.fillRect(o.x+x,o.y+y,1,1);
  }));
  c.globalAlpha=1;
}

// ================= GAME LOGIC =================
function spawn(){
  const t=queue.shift();
  queue.push(bag.next());
  player={type:t,m:PIECES[t].map(r=>r.slice()),x:3,y:0};
  canHold=true;
  if(collide(player)) gameOver();
}

function merge(){
  player.m.forEach((r,y)=>r.forEach((v,x)=>{
    if(v) arena[y+player.y][x+player.x]=player.type;
  }));
}

function sweep(){
  for(let y=ROWS-1;y>=0;y--){
    if(arena[y].every(v=>v)){
      arena.splice(y,1);
      arena.unshift(Array(COLS).fill(0));
      lines++;
      score+=100;
      y++;
    }
  }
}

function drop(){
  player.y++;
  if(collide(player)){
    player.y--;
    merge();
    sweep();
    spawn();
  }
}

// ================= DRAW =================
function draw(){
  ctx.fillStyle='#020617';
  ctx.fillRect(0,0,COLS,ROWS);

  arena.forEach((r,y)=>r.forEach((v,x)=>{
    if(v) drawM([[1]],{x,y},ctx,v);
  }));

  drawM(player.m,{x:player.x,y:player.y},ctx,player.type);

  info.innerText=`Score: ${score}\nLines: ${lines}\nLevel: ${level}`;
}

// ================= LOOP =================
function update(time=0){
  if(isGameOver) return;

  const delta=time-lastTime;
  lastTime=time;
  dropCnt+=delta;

  if(dropCnt>=dropInt){
    drop();
    dropCnt=0;
  }

  draw();
  animationId=requestAnimationFrame(update);
}

// ================= GAME OVER =================
function gameOver(){
  isGameOver=true;
  cancelAnimationFrame(animationId);
  document.getElementById('gameOver').style.display='flex';
}

// ================= BUTTONS =================
document.getElementById('watchAd').onclick=()=>{
  openAd();

  document.getElementById('gameOver').style.display='none';

  arena.forEach(r=>r.fill(0)); // clear board only
  isGameOver=false;
  dropCnt=0;

  spawn();
  lastTime=performance.now();
  animationId=requestAnimationFrame(update);
};

document.getElementById('restart').onclick=()=>location.reload();

// ================= INPUT =================
document.addEventListener('keydown',e=>{
  if(isGameOver||!player) return;

  if(e.key==='ArrowLeft'){player.x--;if(collide(player))player.x++}
  if(e.key==='ArrowRight'){player.x++;if(collide(player))player.x--}
  if(e.key==='ArrowDown') drop();
  if(e.key==='z'||e.key==='ArrowUp'){
    const m=rotate(player.m);
    const o=player.m;
    player.m=m;
    if(collide(player)) player.m=o;
  }
});

// ================= START =================
spawn();
lastTime=performance.now();
animationId=requestAnimationFrame(update);
</script>
</body>
</html>
